// This pipeline revolves around building a Docker image:
// - Lint: Lints a Dockerfile using hadolint
// - detect new secrets: Detect new secrets
// - sonar scanner: Scan source code for vulnerabilities

pipeline {
    environment { // Environment variables defined for all steps
        TOOLS_IMAGE = "127.0.0.1:5000/tools-image"
	SONAR_KEY = "juice-shop"
    }

    agent any

    stages {
        stage("lint") {
            agent {
                docker {
                    image "docker.io/hadolint/hadolint:v1.18.0"
                    reuseNode true
                }
            }
            steps {
                sh label: "Lint Dockerfile", script: "hadolint Dockerfile > hadolint-results.txt"
            }
        }

        stage("detect new secrets") {
            agent {
                docker {
                    image "${TOOLS_IMAGE}"
                    args "--volume /etc/passwd:/etc/passwd:ro"
                    reuseNode true
                }
            }
            steps {
                script {
                    def result = sh label: "detect-secrets",
                        script: """\
                            detect-secrets-hook --no-verify \
                                                -v \
                                                --baseline .secrets.baseline.json \
                            \$(git diff-tree --no-commit-id --name-only -r ${GIT_COMMIT} | xargs -n1)
                        """,
                        returnStatus: true
                        
                        if (result == 1) {
                            error("unaudited secrets have been found")
                        }
                }
            }
        }

       stage("sonnarscanner") {
           agent {
               docker {
                   image "${TOOLS_IMAGE}"
                   // Make sure that username can be mapped correctly
                   args "--volume /etc/passwd:/etc/passwd:ro --network lab"
                   reuseNode true
               }
           }
           steps {
               withSonarQubeEnv("sonarqube.demo.local") {
                 withEnv(['npm_config_cache=npm-cache', 'HOME=.']){
                   sh label: "clear npm cache",
                      script: "npm  cache clear --force"
                   sh label: "install prerequisites",
                      script: "npm install -D typescript"
                   sh label: "sonar-scanner",
                      script: """\
                          sonar-scanner \
                          '-Dsonar.buildString=${BRANCH_NAME}-${BUILD_ID}' \
                          '-Dsonar.projectKey=${SONAR_KEY}' \
                          '-Dsonar.projectVersion=${BUILD_ID}' \
                          '-Dsonar.sources=${WORKSPACE}'
                      """  
                 }
               }
           }
       }
       
     stage("quality gate") {
       steps {
         timeout(time: 1, unit: 'HOURS') {
           waitForQualityGate abortPipeline: true
         }
       }
     }
  
// - Deprecated variant  
/*
    stage("quality gate") {
      steps {
        script {
          withSonarQubeEnv("sonarqube.demo.local") {
              def scannerWorkReportTask = getWorkspaceFileProperties("${env.WORKSPACE}/.scannerwork/report-task.txt")
              def sonarServerUrl = scannerWorkReportTask.getProperty('serverUrl')              
            
              def ceTask
              timeout(time: 2, unit: 'MINUTES') {
                 waitUntil {
                    withCredentials([string(credentialsId: 'SONAR_AUTH_TOKEN', variable: 'AUTH_TOKEN')]) {
                       ceTask = parseResponseFromUrl(sonarServerUrl + "/api/ce/task?id=" + scannerWorkReportTask.getProperty('ceTaskId'), "${AUTH_TOKEN}")
                    }
                 return "SUCCESS".equals(ceTask["task"]["status"])
                 }
              } 

             def qualityGateAnalysisUrl = sonarServerUrl + "/api/qualitygates/project_status?analysisId=" + ceTask["task"]["analysisId"]
             def qualityGateResp

             withCredentials([string(credentialsId: 'SONAR_AUTH_TOKEN', variable: 'AUTH_TOKEN')]) {
                 qualityGateResp = parseResponseFromUrl(qualityGateAnalysisUrl, "${AUTH_TOKEN}")
             }

             if ("ERROR".equals(qualityGateResp["projectStatus"]["status"])) {
                error "Quality Gate failure"
             }
           
         }
       } 
     }
    }
*/
   }
   post {
        always {
             archiveArtifacts artifacts: "*-results.txt"
        }
   }
}

def Properties getWorkspaceFileProperties(filename) {
    def properties = new Properties()
    properties.load(new StringReader(readFile(filename)))
    return properties
}

@NonCPS
def parseResponseFromUrl(String url, String authToken) {
    def response  = sh(script: "curl -u ${authToken}: ${url}", returnStdout: true) 
    def parsedResponse = new groovy.json.JsonSlurperClassic().parseText(response)
    return parsedResponse
}
